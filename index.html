<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Model Viewer</title>
    <style>
      * {
        padding: 0;
        margin: 0;
        box-sizing: border-box;
      }
      body {
        background-color: black;
      }
      #model-container {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <div id="model-container"></div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.172.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.172.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

class ModelViewer {
  constructor(container) {
    // Previous setup code remains the same...
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x000000);

    this.camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    this.camera.position.set(0, 0, 3);

    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(this.renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    this.scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(0, 1, 1);
    this.scene.add(directionalLight);

    this.mouse = new THREE.Vector2();
    this.targetRotation = new THREE.Vector2();
    this.currentRotation = new THREE.Vector2();
    this.isMobile = /Mobi|Android/i.test(navigator.userAgent);

    if (this.isMobile) {
      window.addEventListener("scroll", this.onScroll.bind(this));
    } else {
      window.addEventListener("mousemove", this.onMouseMove.bind(this));
    }
    window.addEventListener("resize", this.onWindowResize.bind(this));

    this.mixer = null;
    this.clock = new THREE.Clock();
    this.model = null;

    this.animate();
  }

  loadModel(url) {
    const loader = new GLTFLoader();

    loader.load(
      url,
      (gltf) => {
        if (this.model) this.scene.remove(this.model);

        this.model = gltf.scene;

        // Center and scale the model
        const box = new THREE.Box3().setFromObject(this.model);
        const center = box.getCenter(new THREE.Vector3());
        this.model.position.set(-center.x, -center.y, -center.z);

        const size = box.getSize(new THREE.Vector3());
        const scale = 4 / Math.max(size.x, size.y, size.z);
        this.model.scale.setScalar(scale);

        // Create a group to handle rotations more easily
        const group = new THREE.Group();
        group.add(this.model);
        this.scene.add(group);
        this.model = group; // Use the group for future rotations

        // Set initial rotation to make model upright and facing camera
        this.model.rotation.order = 'XYZ';
        this.model.rotation.x = -Math.PI / 2; // Rotate 90 degrees to stand upright
        this.model.rotation.y = Math.PI; // Rotate 180 degrees to face camera
        this.model.rotation.z = Math.PI;

        // Enable shadows
        gltf.scene.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        if (gltf.animations.length) {
          this.mixer = new THREE.AnimationMixer(gltf.scene);
          gltf.animations.forEach((clip) => this.mixer.clipAction(clip).play());
        }
      },
      (xhr) => console.log(`${(xhr.loaded / xhr.total) * 100}% loaded`),
      (error) => console.error("Error loading model:", error)
    );
  }

  updateModelRotation() {
    if (!this.model) return;

    this.currentRotation.y += (this.targetRotation.y - this.currentRotation.y) * 0.1;
    this.currentRotation.x += (this.targetRotation.x - this.currentRotation.x) * 0.1;

    // Apply rotations while maintaining upright orientation
    this.model.rotation.x = -Math.PI / 2 + this.currentRotation.x;
    this.model.rotation.y = Math.PI + this.currentRotation.y;
  }

  // Rest of the methods remain the same...
  onMouseMove(event) {
    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
    // Adjust the target rotation to make the model "look" at the cursor naturally
    const intensity = 0.1; // Controls how strongly the model follows the mouse
    this.targetRotation.y = this.mouse.x * Math.PI * intensity; // Face right and left
    this.targetRotation.x = -this.mouse.y * Math.PI * intensity;  // Invert Y-axis to correct behavior
  }


  onScroll() {
    const scrollY = window.scrollY / window.innerHeight;
    this.targetRotation.x = scrollY * Math.PI * 0.05;
  }

  onWindowResize() {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }

  animate() {
    requestAnimationFrame(() => this.animate());

    if (this.mixer) {
      const delta = this.clock.getDelta();
      this.mixer.update(delta);
    }

    this.updateModelRotation();
    this.renderer.render(this.scene, this.camera);
  }
}

const container = document.getElementById("model-container");
const viewer = new ModelViewer(container);
viewer.loadModel("/assets/models/greetings.glb");
    </script>
  </body>
</html>
